Simple Story (Very Human)

There is a mystery machine (black box).

You give it an input x
It gives an output f(x)

But there is a hidden rule:

There exists a secret binary string s
such that
f(x) = f(x âŠ• s)

(âŠ• = XOR, think â€œdifference patternâ€)

What This Means (Plain Words)

Every output is produced by two different inputs

Those two inputs differ by the same secret string s

Your job: find s

Tiny Example

Secret:

s = 101


Then:

f(000) = f(101)
f(011) = f(110)


Same output â†’ inputs differ by 101

ğŸ˜“ Classical Computer (Big Trouble)

To find s:

Must store many inputâ€“output pairs

Look for collisions

Needs exponential time

As input size grows â†’ impossible fast

ğŸ˜ Quantum Computer (Breakthrough)

Quantum computer:

Tries all inputs at once

Measures relationships, not values

Finds s in polynomial time

ğŸ’¥ Exponential speedup

This was the first proof such a speedup is possible.

ğŸ”Œ 2. Circuit Walkthrough (Step by Step, Calmly)
Qubits Used

n input qubits

n output qubits

Example:
If s has 3 bits â†’ total 6 qubits

ğŸŸ¢ Step 1: Initialize
Input:  |0âŸ© |0âŸ© |0âŸ©
Output: |0âŸ© |0âŸ© |0âŸ©

ğŸŸ¢ Step 2: Hadamard on INPUT qubits

Now input qubits represent:

All possible x values at once

This is asking:

â€œWhat patterns exist in this function?â€

ğŸŸ¢ Step 3: Oracle (The Black Box)

Oracle computes:

|xâŸ©|0âŸ© â†’ |xâŸ©|f(x)âŸ©


Because of the hidden rule:

States become paired

Each pair differs by s

ğŸ§  This pairing is the key insight.

ğŸŸ¢ Step 4: Measure OUTPUT qubits

This:

Collapses output

Leaves input in a superposition of x and xâŠ•s

You donâ€™t see s yet â€” but itâ€™s encoded.

ğŸŸ¢ Step 5: Hadamard on INPUT qubits

Now interference happens.

Result:

Measurement gives a string y

That string satisfies:

y Â· s = 0   (mod 2)


This is a linear equation.

ğŸŸ¢ Step 6: Repeat

Each run gives one equation.

After enough runs:

You have enough equations

Solve them classically

ğŸ¯ You get s

ğŸ§ª 3. Python (Qiskit) â€“ Simplified Demo

Letâ€™s assume secret:

s = 110

from qiskit import QuantumCircuit, Aer, execute
import numpy as np

n = 3
qc = QuantumCircuit(2*n, n)

# Step 2: Hadamard on input register
for i in range(n):
    qc.h(i)

# ---- ORACLE (example for s = 110) ----
qc.cx(0, 3)
qc.cx(1, 4)
qc.cx(2, 5)
qc.cx(1, 3)
qc.cx(2, 3)
# ------------------------------------

# Measure output register
for i in range(n):
    qc.measure(i+n, i)

# Hadamard on input again
for i in range(n):
    qc.h(i)

# Measure input
for i in range(n):
    qc.measure(i, i)

backend = Aer.get_backend('qasm_simulator')
result = execute(qc, backend, shots=1024).result()
print(result.get_counts())

What You Do With Results

Collect several outputs like:

010, 001, 111


These form equations

Solve them â†’ get s

(Exact math can wait â€” concept matters now)

ğŸŒ 4. Real-World Meaning (VERY IMPORTANT)

Simonâ€™s Problem is not a toy.

What Simonâ€™s Algorithm Really Does

Finds hidden periodic structure exponentially faster

Where This Idea Is Used
Area	Meaning
Cryptography	Breaking hidden-key structures
Shorâ€™s Algorithm	Factoring & RSA breaking
Pattern discovery	Hidden symmetry detection
Cybersecurity	Structural vulnerability analysis
Quantum ML	Kernel & feature space discovery
Why History Cares

First proof of exponential quantum advantage

Inspired Shorâ€™s algorithm

Changed computer science forever

Without Simon:
âŒ No quantum crypto threat
âŒ No modern quantum algorithms
