# âš›ï¸ Part 4: Simonâ€™s Algorithm (The Big Breakthrough)

> **"The moment we realized quantum computers aren't just fasterâ€”they are in a different league."**



**Simon's Algorithm** is historically critical. While previous algorithms showed small speedups, Simon's Algorithm was the first to demonstrate an **Exponential Speedup**. It solves a problem in polynomial time that takes a classical computer exponential time.

---

## ğŸ–¼ï¸ 1. Picture-Based Intuition (The Story)

### The Mystery Machine
Imagine a Black Box function $f(x)$.
* You give it an input $x$.
* It gives an output $f(x)$.

**The Hidden Rule:**
The function is "2-to-1". This means every unique output is produced by exactly **two** different inputs.
These two inputs are related by a hidden **Secret String ($s$)** via XOR ($\oplus$).

$$f(x) = f(x \oplus s)$$

> **Simply put:** If you put in `000` and get "Apple", and you put in `101` and get "Apple", then the secret string $s$ is the difference between `000` and `101` (which is `101`).

**ğŸ‘‰ Your Job:** Find the secret string $s$.

---

## ğŸ¢ vs âš¡: The Exponential Gap

This is where the magic happens.

| Feature | ğŸ’» Classical Computer | âš›ï¸ Quantum Computer |
| :--- | :--- | :--- |
| **Strategy** | Random Guessing (Collision Search) | Period Finding (Interference) |
| **The Struggle** | You have to keep checking random inputs until you stumble upon two that give the same answer. | You find the underlying "period" or structure of the function. |
| **Time Needed** | **Exponential** ($2^{n/2}$) | **Polynomial** ($O(n)$) |
| **Why it matters** | As the string gets longer, this becomes impossible for classical computers. | Quantum computers solve it efficiently regardless of length. |

---

## ğŸ”Œ 2. Circuit Walkthrough (Step-by-Step)

How do we find the structure without checking every number?



**The Setup:**
* **Input Register ($n$ qubits):** Where we test values.
* **Output Register ($n$ qubits):** Where the function writes results.
* **Example:** If $s = 101$ (3 bits), we need 6 qubits total.

### ğŸŸ¢ Step 1: Initialize
Start with everything at $|0\rangle$.

### ğŸŸ¢ Step 2: Hadamard on INPUT
We create a superposition of **all possible inputs** ($x$).
* *Think:* "We are feeding every possible number into the machine at once."

### ğŸŸ¢ Step 3: The Oracle
The black box runs.
* Because of the hidden rule ($x$ and $x \oplus s$ give the same output), the quantum state becomes **entangled**.
* The inputs are now "paired up" based on the secret $s$.

### ğŸŸ¢ Step 4: Measure OUTPUT Register
We measure the bottom qubits.
* This is a cool trick. Measuring the output "collapses" the input register.
* The input is no longer "all numbers." It is now a superposition of just **two** numbers: a specific $|a\rangle$ and its partner $|a \oplus s\rangle$.
* *Note:* We don't know what $a$ is, and we don't see $s$ yet.

### ğŸŸ¢ Step 5: Hadamard on INPUT again
We apply H-gates to the input.
* This causes **Interference** between the two remaining states ($|a\rangle$ and $|a \oplus s\rangle$).
* **Constructive Interference** happens only for bitstrings ($y$) that satisfy a specific equation:
  $$y \cdot s = 0 \pmod 2$$

### ğŸŸ¢ Step 6: Measure Input & Solve
We measure the input and get a string $y$.
* We repeat this process $\approx n$ times to get several different $y$ values.
* We solve these linear equations (classically) to find $s$.

---

## ğŸ§ª 3. Python Implementation (Qiskit)

*Note: In this simplified demo, we focus on generating the equations.*

```python
from qiskit import QuantumCircuit, Aer, execute
from qiskit.visualization import plot_histogram

# Setup
n = 3
# s = '110' (We build the oracle to match this secret)

qc = QuantumCircuit(2*n, n)

# --- Step 2: Hadamard on Input ---
for i in range(n):
    qc.h(i)

# --- Step 3: ORACLE (Hardcoded for s = 110) ---
qc.barrier()
# This specific sequence of gates ensures f(x) = f(x ^ 110)
qc.cx(0, 3)
qc.cx(1, 4)
qc.cx(2, 5)
qc.cx(1, 3)
qc.cx(2, 3)
qc.barrier()

# --- Step 4: Measure Output (Optional in theory, helpful in practice) ---
# In many textbook circuits, we strictly measure input at the end, 
# but measuring output here conceptually collapses the state.
# (We are not measuring these to get the answer, just to collapse state)
# qc.measure(range(n, 2*n), range(n)) 

# --- Step 5: Hadamard on Input ---
for i in range(n):
    qc.h(i)

# --- Step 6: Measure Input ---
qc.barrier()
for i in range(n):
    qc.measure(i, i)

# --- Run ---
print("Running Simon's Algorithm...")
backend = Aer.get_backend('qasm_simulator')
result = execute(qc, backend, shots=1024).result()
counts = result.get_counts()

print("\nMeasurement Results (y values):", counts)
# These results are NOT 's'. 
# These are values 'y' such that (y . s) = 0.
# You would take these bitstrings and solve a system of linear equations to find s.
